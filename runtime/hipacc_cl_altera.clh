#pragma OPENCL EXTENSION cl_altera_channels : enable

#define ARRY  0
#define CHNNL 1



/* ***************** ADDITIONAL DATA STRUCTURES **************************** */
#define char1 char
typedef struct{char16  s[2];}char32;
typedef struct{char16  s[4];}char64;
typedef struct{char16  s[8];}char128;
typedef struct{char16 s[16];}char256;

#define uchar1 uchar
typedef struct{uchar16  s[2];}uchar32;
typedef struct{uchar16  s[4];}uchar64;
typedef struct{uchar16  s[8];}uchar128;
typedef struct{uchar16 s[16];}uchar256;

#define short1 short
typedef struct{short16  s[2];}short32;
typedef struct{short16  s[4];}short64;
typedef struct{short16  s[8];}short128;
typedef struct{short16 s[16];}short256;

#define ushort1 ushort
typedef struct{ushort16  s[2];}ushort32;
typedef struct{ushort16  s[4];}ushort64;
typedef struct{ushort16  s[8];}ushort128;
typedef struct{ushort16 s[16];}ushort256;

#define int1 int
typedef struct{int16  s[2];}int32;
typedef struct{int16  s[4];}int64;
typedef struct{int16  s[8];}int128;
typedef struct{int16 s[16];}int256;

#define uint1 uint
typedef struct{uint16  s[2];}uint32;
typedef struct{uint16  s[4];}uint64;
typedef struct{uint16  s[8];}uint128;
typedef struct{uint16 s[16];}uint256;

#define long1 long
typedef struct{long16  s[2];}long32;
typedef struct{long16  s[4];}long64;
typedef struct{long16  s[8];}long128;
typedef struct{long16 s[16];}long256;

#define ulong1 ulong
typedef struct{ulong16  s[2];}ulong32;
typedef struct{ulong16  s[4];}ulong64;
typedef struct{ulong16  s[8];}ulong128;
typedef struct{ulong16 s[16];}ulong256;

#define float1 float
typedef struct{float16  s[2];}float32;
typedef struct{float16  s[4];}float64;
typedef struct{float16  s[8];}float128;
typedef struct{float16 s[16];}float256;

#define double1 double
typedef struct{double16  s[2];}double32;
typedef struct{double16  s[4];}double64;
typedef struct{double16  s[8];}double128;
typedef struct{double16 s[16];}double256;


/* ********************** Tools for Kernel Code **************************** */
#define createChannel(TYPE, NAME, VECT_SIZE) \
            channel TYPE ## VECT_SIZE NAME __attribute__((depth(1)))


#define getWindowAt(ARRAY, __x, __y) ARRAY[__y][__x]


/* ******************** Boundary Conditions******************************** */
/*********************************************************** Select OUTPUT */
#define SELECT_OUT_UNDEFINED(DC__bVECT_INDX, VECT_INDX, DCVECT_SIZE, wndOUT, wndIN, DCselectOUT, DC__SlidingSIZE, DCy, DCx) \
        _Pragma("unroll") for (uint __j = 0; __j < __SIZE_Y; __j++) { \
            _Pragma("unroll") for (uint __i = 0; __i < __SIZE_X; __i++){ \
                    wndOUT[__j][__i] = wndIN[__j][VECT_INDX+__i];\
            }\
        }


#define SELECT_OUT_CONSTANT(__bVECT_INDX, VECT_INDX, VECT_SIZE, wndOUT, wndIN, DCselectOUT, __SlidingSIZE, __y, __x, constVar) \
        bool selectOUT[__SIZE_X][__SIZE_Y];\
        /* Initialize selection signals */ \
        _Pragma("unroll")\
        for(uint __j=0; __j< __SIZE_Y; __j++)\
            _Pragma("unroll")\
            for(uint __i=0; __i<__SIZE_X; __i++)\
                selectOUT[__j][__i]=0;\
        /* Update selection signals according to __y */ \
        _Pragma("unroll") for (uint __j=0; __j< __halfSIZE_Y; __j++){\
            _Pragma("unroll") for(uint __i=0; __i<__SIZE_X; __i++){\
                if(__y<__j+1)        selectOUT[__halfSIZE_Y-1-__j][__i] = 1;\
                if(__y>__HEIGHT-2-__j) selectOUT[__halfSIZE_Y+1+__j][__i] = 1;\
            }\
        }\
        /* Update selection signals according to __x */ \
        _Pragma("unroll") for (uint __i=0; __i< __halfSIZE_X; __i++){\
            _Pragma("unroll") for(uint __j=0; __j<__SIZE_Y; __j++){\
                if(__x+VECT_INDX<__i+1) selectOUT[__j][__halfSIZE_X-1-__i] = 1;\
                if(__x+VECT_INDX>__WIDTH-2-__i) selectOUT[__j][__halfSIZE_X+1+__i] = 1;\
            }\
        }\
        /* Select output data according to selection signals */ \
        _Pragma("unroll") \
        for (uint __j = 0; __j < __SIZE_Y; __j++) { \
            _Pragma("unroll") \
            for (uint __i = 0; __i < __SIZE_X; __i++) { \
                wndOUT[__j][__i] = selectOUT[__j][__i] ? constVar : wndIN[__j][VECT_INDX+__i];\
            }\
        }


#define SELECT_OUT_CLAMP(__bVECT_INDX, VECT_INDX, VECT_SIZE, wndOUT, wndIN, selectOUT, __SlidingSIZE, DCy, DCx) \
        _Pragma("unroll") for (uint __j = 0; __j < __SIZE_Y; __j++) { \
            _Pragma("unroll") for (uint __i = 0; __i < __SIZE_X; __i++){ \
                if( (__halfSIZE_X > __bVECT_INDX+VECT_SIZE-1-VECT_INDX) &&\
                    (__i > __halfSIZE_X) &&\
                    (__i > __SIZE_X-2-(__halfSIZE_X-(__bVECT_INDX+VECT_SIZE-VECT_INDX))) )\
                    wndOUT[__j][__i] = selectOUT ? wndIN[__j][__SlidingSIZE-2*__halfSIZE_X+__i-1]\
                                             : wndIN[__j][VECT_INDX+__i];\
                else\
                    wndOUT[__j][__i] = wndIN[__j][VECT_INDX+__i];\
            }\
        }


#define SELECT_OUT_MIRROR(__bVECT_INDX, VECT_INDX, VECT_SIZE, wndOUT, wndIN, selectOUT, __SlidingSIZE, DCy, DCx) \
        SELECT_OUT_CLAMP(__bVECT_INDX, VECT_INDX, VECT_SIZE, wndOUT, wndIN, selectOUT, __SlidingSIZE, DCy, DCx) \


#define SELECT_OUT_MIRROR_101(__bVECT_INDX, VECT_INDX, VECT_SIZE, wndOUT, wndIN, selectOUT, __SlidingSIZE, DCy, DCx) \
        SELECT_OUT_CLAMP(__bVECT_INDX, VECT_INDX, VECT_SIZE, wndOUT, wndIN, selectOUT, __SlidingSIZE, DCy, DCx) \


/********************************** Warp pixel row coming from row buffer */
#define WARPy_UNDEFINED(VECT_SIZE, wnd, __rselect, __SlidingCoordNewP, __y, DCx)


#define WARPy_CONSTANT(VECT_SIZE, wnd, __rselect, __SlidingCoordNewP, __y, DCx)


#define WARPy_CLAMP(VECT_SIZE, wnd, __rselect, __SlidingCoordNewP, __y, DCx) \
        _Pragma("unroll")  for (uint __j=0; __j< __halfSIZE_Y; __j++){\
            _Pragma("unroll") for(uint __i=0; __i<VECT_SIZE; __i++){\
                if( __y<=__j )\
                    wnd[__halfSIZE_Y-1-__j][__SlidingCoordNewP+__i] = wnd[__halfSIZE_Y-__j][__SlidingCoordNewP+__i];\
                if( __y>=__HEIGHT-1-__j )\
                    wnd[__halfSIZE_Y+1+__j][__SlidingCoordNewP+__i] = wnd[__halfSIZE_Y+__j][__SlidingCoordNewP+__i];\
            }\
        }\
        \
        /* Right Boundary Condition */ \
        if(!__rselect){\
            _Pragma("unroll") for(uint __j=0; __j<__SIZE_Y; __j++)\
                _Pragma("unroll")\
                for(int __i=__halfSIZE_X; (__i>__halfSIZE_X-VECT_SIZE && __i>0); __i--)\
                    wnd[__j][__SlidingCoordNewP+VECT_SIZE+__i-1] = wnd[__j][__SlidingCoordNewP+VECT_SIZE-1];\
        }


#define WARPy_MIRROR(VECT_SIZE, wnd, __rselect, __SlidingCoordNewP, __y, DCx) \
        _Pragma("unroll")  for (uint __j=0; __j< __halfSIZE_Y; __j++){\
            _Pragma("unroll") for(uint jc=0; jc<__halfSIZE_Y; jc++){\
                _Pragma("unroll") for(uint __i=0; __i<VECT_SIZE; __i++){\
                    if(__y==__j && jc<__halfSIZE_Y-__j)\
                        wnd[jc][__SlidingCoordNewP+__i] = wnd[__SIZE_Y-2-2*__j-jc][__SlidingCoordNewP+__i];\
                    if(__y==__HEIGHT-1-__j && jc<__halfSIZE_Y-__j)\
                        wnd[__SIZE_Y-1-jc][__SlidingCoordNewP+__i] = wnd[1+2*__j+jc][__SlidingCoordNewP+__i];\
                }\
            }\
        }\
        \
        /* Right Boundary Condition */ \
        if(!__rselect){\
            _Pragma("unroll") for(uint __j=0; __j<__SIZE_Y; __j++){\
                /* Shift right boundary pixels (Better Fanout) */ \
                if(__halfSIZE_X > VECT_SIZE){\
                    _Pragma("unroll") for(uint __i=0; __i<__halfSIZE_X-VECT_SIZE; __i++)\
                        wnd[__j][__SlidingCoordNewP+VECT_SIZE+__i] = wnd[__j][__SlidingCoordNewP+VECT_SIZE+__i+VECT_SIZE];\
                }\
                /* Store new pixels */ \
                _Pragma("unroll")\
                for(int __i=__halfSIZE_X; (__i>__halfSIZE_X-VECT_SIZE && __i>0); __i--)\
                    wnd[__j][__SlidingCoordNewP+VECT_SIZE-1+__i] = wnd[__j][__SlidingCoordNewP+VECT_SIZE-1-__halfSIZE_X+__i];\
            }\
        }


#define WARPy_MIRROR_101(VECT_SIZE, wnd, __rselect, __SlidingCoordNewP, __y, DCx) \
        _Pragma("unroll")  for (uint __j=0; __j< __halfSIZE_Y; __j++){\
            _Pragma("unroll") for(uint jc=0; jc<__halfSIZE_Y; jc++){\
                _Pragma("unroll") for(uint __i=0; __i<VECT_SIZE; __i++){\
                    if(__y==__j && jc<__halfSIZE_Y-__j)\
                        wnd[jc][__SlidingCoordNewP+__i] = wnd[__SIZE_Y-1-2*__j-jc][__SlidingCoordNewP+__i];\
                    if(__y==__HEIGHT-1-__j && jc<__halfSIZE_Y-__j)\
                        wnd[__SIZE_Y-1-jc][__SlidingCoordNewP+__i] = wnd[2*__j+jc][__SlidingCoordNewP+__i];\
                }\
            }\
        }\
        /* Left Boundary Condition 0th pixel */ \
        if(__x==0) for(uint __j=0; __j<__SIZE_Y; __j++)\
            wnd[__j][0] = wnd[__j][__SIZE_X-1];\
        \
        /* Right Boundary Condition */ \
        if(!__rselect){\
            _Pragma("unroll") for(uint __j=0; __j<__SIZE_Y; __j++){\
                /* Shift right boundary pixels (Better Fanout) */ \
                if(__halfSIZE_X > VECT_SIZE){\
                    _Pragma("unroll") for(uint __i=0; __i<__halfSIZE_X-VECT_SIZE; __i++)\
                        wnd[__j][__SlidingCoordNewP+VECT_SIZE+__i] = wnd[__j][__SlidingCoordNewP+VECT_SIZE+__i+VECT_SIZE];\
                }\
                /* Store new pixels */ \
                _Pragma("unroll")\
                for(int __i=__halfSIZE_X; (__i>__halfSIZE_X-VECT_SIZE && __i>0); __i--)\
                    wnd[__j][__SlidingCoordNewP+VECT_SIZE-1+__i] = wnd[__j][__SlidingCoordNewP+VECT_SIZE-2-__halfSIZE_X+__i];\
            }\
        }


/*************************************************** Shift Sliding Window */
#define SLIDEWx_UNDEFINED(VECT_SIZE, INTYPE, wnd, newPixel, __SlidingCoordNewP, __j, DCx)\
        /* Shift old pixels */ \
        _Pragma("unroll") for(uint __i=0; __i<__SlidingCoordNewP; __i++)\
            wnd[__j][__i] = wnd[__j][__i+VECT_SIZE];\
        /* Store new pixels */ \
        _Pragma("unroll") for(uint __i=0; __i<VECT_SIZE; __i++)\
            wnd[__j][__SlidingCoordNewP+__i] = ((INTYPE*)&newPixel)[__i];


#define SLIDEWx_CONSTANT(VECT_SIZE, INTYPE, wnd, newPixel, __SlidingCoordNewP, __j, DCx)\
        SLIDEWx_UNDEFINED(VECT_SIZE, INTYPE, wnd, newPixel, __SlidingCoordNewP, __j, DCx)\

#define SLIDEWx_CLAMP(VECT_SIZE, INTYPE, wnd, newPixel, __SlidingCoordNewP, __j, __x)\
        /* Shift old pixels */ \
        _Pragma("unroll") for(uint __i=0; __i<__SlidingCoordNewP; __i++)\
            wnd[__j][__i] = wnd[__j][__i+VECT_SIZE];\
        /* Shift right boundary pixels (Better Fanout) */ \
        if(__halfSIZE_X > VECT_SIZE){\
            _Pragma("unroll") for(uint __i=0; __i<__halfSIZE_X-VECT_SIZE; __i++)\
                wnd[__j][__SlidingCoordNewP+VECT_SIZE+__i] = wnd[__j][__SlidingCoordNewP+VECT_SIZE+__i+VECT_SIZE];\
        }\
        /* Store new pixels */ \
        _Pragma("unroll") for(uint __i=0; __i<VECT_SIZE; __i++)\
            wnd[__j][__SlidingCoordNewP+__i] = ((INTYPE*)&newPixel)[__i];\
        /* Left Boundary Condition */ \
        if(__x==0){\
            INTYPE bndPixel = wnd[__j][__halfSIZE_X];\
            for(uint __i=0; __i<__halfSIZE_X; __i++) wnd[__j][__i] = bndPixel;\
        }\


#define SLIDEWx_MIRROR(VECT_SIZE, INTYPE, wnd, newPixel, __SlidingCoordNewP, __j, __x)\
        /* Shift old pixels */ \
        _Pragma("unroll") for(uint __i=0; __i<__SlidingCoordNewP; __i++)\
            wnd[__j][__i] = wnd[__j][__i+VECT_SIZE];\
        /* Store new pixels */ \
        _Pragma("unroll") for(uint __i=0; __i<VECT_SIZE; __i++)\
            wnd[__j][__SlidingCoordNewP+__i] = ((INTYPE*)&newPixel)[__i];\
        /* Left Boundary Condition */ \
        if(__x==0){\
            for(uint __i=0; __i<__halfSIZE_X; __i++) wnd[__j][__i] = wnd[__j][__SIZE_X-2-__i];\
        }\


#define SLIDEWx_MIRROR_101(VECT_SIZE, INTYPE, wnd, newPixel, __SlidingCoordNewP, __j, __x)\
        /* Shift old pixels */ \
        _Pragma("unroll") for(uint __i=0; __i<__SlidingCoordNewP; __i++)\
            wnd[__j][__i] = wnd[__j][__i+VECT_SIZE];\
        /* Store new pixels */ \
        _Pragma("unroll") for(uint __i=0; __i<VECT_SIZE; __i++)\
            wnd[__j][__SlidingCoordNewP+__i] = ((INTYPE*)&newPixel)[__i];\
        /* Left Boundary Condition */ \
        if(__x==0){\
            for(uint __i=0; __i<__halfSIZE_X; __i++) wnd[__j][__i] = wnd[__j][__SIZE_X-1-__i];\
        }\


/* ***********************PROCESS TYPES************************************* */
#define readPixelfARRY(VECT_SIZE, INTYPE, outPIXEL, inARRAY, index) \
            outPIXEL = ((__global INTYPE ## VECT_SIZE *)inARRAY)[index]; \


#define readPixelfCHNNL(DCVECT_SIZE, DCINTYPE, outPIXEL, inCHANNEL, DCindex)\
            outPIXEL = read_channel_altera(inCHANNEL); \
            mem_fence(CLK_CHANNEL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE); \


#define write2ARRY(VECT_SIZE, OUTTYPE, outARRAY, outPIXEL, index) \
            ((__global OUTTYPE ## VECT_SIZE *)outARRAY)[index] = outPIXEL; \


#define write2CHNNL(DCVECT_SIZE, DCOUTTYPE, outCHANNEL, outPIXEL, DCindex) \
            write_channel_altera(outCHANNEL, outPIXEL); \
            mem_fence(CLK_CHANNEL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE); \


/* ******************VECTORIZED PIPELINE FUNCTIONS********************************* */
#define processPixels(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, SRC, READTYPE, IM_WIDTH, IM_HEIGHT, KERNEL) \
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    \
    uint __count = 0; \
    uint __x = 0, __y = 0;\
    while (__count != __vecSIZE) { \
        INTYPE ## VECT_SIZE __newpixel; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
        }\
        /* Execute Kernel According to Boundary Conditions */ \
        OUTTYPE ## VECT_SIZE __outPixel;\
        _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
            ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(((INTYPE*)&__newpixel)[__vi]);\
        }\
        write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count);\
       \
        __x+=VECT_SIZE; \
        if(__x == __WIDTH-VECT_SIZE){\
            __x = 0; \
            __y++;\
        }\
        __count++; \
    }


#define process(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, SRC, READTYPE, IM_WIDTH, IM_HEIGHT, KERNEL, KRNL_SIZE_X, KRNL_SIZE_Y, BORDER, ...) \
    const int __SIZE_X = KRNL_SIZE_X;\
    const int __SIZE_Y = KRNL_SIZE_Y;\
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const int __halfSIZE_Y = (__SIZE_Y >> 1);\
    const int __halfSIZE_X = (__SIZE_X >> 1);\
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    const uint __DELAY     = ((__WIDTH*__halfSIZE_Y) + __halfSIZE_X);\
    \
    const uint __vecWIDTH = ((__WIDTH-1)/VECT_SIZE)+1; \
    const uint __vecDELAY = ((__DELAY-1)/VECT_SIZE)+1; \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    const uint __Nvec = ((__halfSIZE_X-1)/VECT_SIZE)+1;\
    const uint __SlidingSIZE = __halfSIZE_X+(1+__Nvec)*VECT_SIZE+__halfSIZE_X;\
    const uint __SlidingCoordNewP = __SlidingSIZE-__halfSIZE_X-VECT_SIZE;\
    \
    INTYPE ## VECT_SIZE __rows[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding[__SIZE_Y][__SlidingSIZE]; \
    uint __count = 0; \
    uint __x = 0, __y = 0, __y_next = 0;\
    bool __rselect=0; \
    uint __bVECT_INDX = (__Nvec-1)*VECT_SIZE;\
    while (__count != __vecDELAY+__vecSIZE) { \
        /* Shift Row Buffers and Sliding Window */ \
        _Pragma("unroll") \
        for(uint __j=0; __j<__SIZE_Y-1; ++__j){ \
            INTYPE ## VECT_SIZE __newPixel = __rows[__j][__vecWIDTH-1]; \
            if(__j != 0) __rows[__j-1][0] = __newPixel;\
            _Pragma("unroll") \
            for(uint __i = __vecWIDTH-1; __i > 0; --__i) __rows[__j][__i] = __rows[__j][__i - 1]; \
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding, __newPixel, __SlidingCoordNewP, __j, __x);\
        }\
        INTYPE ## VECT_SIZE __newpixel; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
            __rows[__SIZE_Y-2][0] = __newpixel; \
        }\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding, __newpixel, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        /* Warp pixel row coming from row buffer */ \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding, __rselect, __SlidingCoordNewP, __y_next, __x); \
        /* Execute Kernel According to Boundary Conditions */ \
        if (__count >= __vecDELAY) { \
            OUTTYPE ## VECT_SIZE __outPixel;\
            _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
                INTYPE __wnd[__SIZE_Y][__SIZE_X]; \
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd, __wnd_sliding, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(__wnd);\
            }\
            write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count-__vecDELAY);\
           \
            __x+=VECT_SIZE; \
            const uint rflagCoord = __halfSIZE_X>VECT_SIZE ? __WIDTH-__Nvec*VECT_SIZE : __WIDTH-VECT_SIZE;\
            if(__x == rflagCoord){\
                __rselect=1;\
                __y_next++;\
            }else if (__x == __WIDTH) { \
                __x = 0; \
                __y = __y_next; \
                __rselect = 0;\
                __bVECT_INDX = (__Nvec-1) * VECT_SIZE;\
            }else if(__x > rflagCoord){\
                __bVECT_INDX-= VECT_SIZE;\
            }\
        } \
        ++__count; \
    }

/* ******************Multiple Inputs********************************* */

#define process5to1(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, SRC, READTYPE, SRC1, READTYPE1, SRC2, READTYPE2, SRC3, READTYPE3, SRC4, READTYPE4, IM_WIDTH, IM_HEIGHT, KERNEL, KRNL_SIZE_X, KRNL_SIZE_Y, BORDER, ...) \
    const int __SIZE_X = KRNL_SIZE_X;\
    const int __SIZE_Y = KRNL_SIZE_Y;\
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const int __halfSIZE_Y = (__SIZE_Y >> 1);\
    const int __halfSIZE_X = (__SIZE_X >> 1);\
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    const uint __DELAY     = ((__WIDTH*__halfSIZE_Y) + __halfSIZE_X);\
    \
    const uint __vecWIDTH = ((__WIDTH-1)/VECT_SIZE)+1; \
    const uint __vecDELAY = ((__DELAY-1)/VECT_SIZE)+1; \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    const uint __Nvec = ((__halfSIZE_X-1)/VECT_SIZE)+1;\
    const uint __SlidingSIZE = __halfSIZE_X+(1+__Nvec)*VECT_SIZE+__halfSIZE_X;\
    const uint __SlidingCoordNewP = __SlidingSIZE-__halfSIZE_X-VECT_SIZE;\
    \
    uint __count = 0; \
    uint __x = 0, __y = 0, __y_next = 0;\
    bool __rselect=0; \
    uint __bVECT_INDX = (__Nvec-1)*VECT_SIZE;\
    /* 0th Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding[__SIZE_Y][__SlidingSIZE]; \
    /* 1st Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows1[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding1[__SIZE_Y][__SlidingSIZE]; \
    /* 2nd Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows2[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding2[__SIZE_Y][__SlidingSIZE]; \
    /* 3rd Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows3[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding3[__SIZE_Y][__SlidingSIZE]; \
    /* 4th Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows4[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding4[__SIZE_Y][__SlidingSIZE]; \
    while (__count != __vecDELAY+__vecSIZE) { \
        /* Shift Row Buffers and Sliding Window */ \
        _Pragma("unroll") \
        for(uint __j=0; __j<__SIZE_Y-1; ++__j){ \
            INTYPE ## VECT_SIZE __newPixel  =  __rows[__j][__vecWIDTH-1]; \
            INTYPE ## VECT_SIZE __newPixel1 = __rows1[__j][__vecWIDTH-1]; \
            INTYPE ## VECT_SIZE __newPixel2 = __rows2[__j][__vecWIDTH-1]; \
            INTYPE ## VECT_SIZE __newPixel3 = __rows3[__j][__vecWIDTH-1]; \
            INTYPE ## VECT_SIZE __newPixel4 = __rows4[__j][__vecWIDTH-1]; \
            if(__j != 0){\
                 __rows[__j-1][0] = __newPixel;\
                __rows1[__j-1][0] = __newPixel1;\
                __rows2[__j-1][0] = __newPixel2;\
                __rows3[__j-1][0] = __newPixel3;\
                __rows4[__j-1][0] = __newPixel4;\
            }\
            _Pragma("unroll") \
            for(uint __i = __vecWIDTH-1; __i > 0; --__i){\
              __rows[__j][__i]  =  __rows[__j][__i - 1]; \
              __rows1[__j][__i] = __rows1[__j][__i - 1]; \
              __rows2[__j][__i] = __rows2[__j][__i - 1]; \
              __rows3[__j][__i] = __rows3[__j][__i - 1]; \
              __rows4[__j][__i] = __rows4[__j][__i - 1]; \
            }\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE,  __wnd_sliding,  __newPixel, __SlidingCoordNewP, __j, __x);\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding1, __newPixel1, __SlidingCoordNewP, __j, __x);\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding2, __newPixel2, __SlidingCoordNewP, __j, __x);\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding3, __newPixel3, __SlidingCoordNewP, __j, __x);\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding4, __newPixel4, __SlidingCoordNewP, __j, __x);\
        }\
        INTYPE ## VECT_SIZE __newpixel; \
        INTYPE ## VECT_SIZE __newpixel1; \
        INTYPE ## VECT_SIZE __newpixel2; \
        INTYPE ## VECT_SIZE __newpixel3; \
        INTYPE ## VECT_SIZE __newpixel4; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
            __rows[__SIZE_Y-2][0] = __newpixel; \
            readPixelf ## READTYPE1(VECT_SIZE, INTYPE, __newpixel1, SRC1, __count);\
            __rows1[__SIZE_Y-2][0] = __newpixel1; \
            readPixelf ## READTYPE2(VECT_SIZE, INTYPE, __newpixel2, SRC2, __count);\
            __rows2[__SIZE_Y-2][0] = __newpixel2; \
            readPixelf ## READTYPE3(VECT_SIZE, INTYPE, __newpixel3, SRC3, __count);\
            __rows3[__SIZE_Y-2][0] = __newpixel3; \
            readPixelf ## READTYPE4(VECT_SIZE, INTYPE, __newpixel4, SRC4, __count);\
            __rows4[__SIZE_Y-2][0] = __newpixel4; \
        }\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE , __wnd_sliding,  __newpixel, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding1, __newpixel1, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding2, __newpixel2, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding3, __newpixel3, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding4, __newpixel4, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        /* Warp pixel row coming from row buffer */ \
        WARPy_ ## BORDER(VECT_SIZE,  __wnd_sliding, __rselect, __SlidingCoordNewP, __y_next, __x); \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding1, __rselect, __SlidingCoordNewP, __y_next, __x); \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding2, __rselect, __SlidingCoordNewP, __y_next, __x); \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding3, __rselect, __SlidingCoordNewP, __y_next, __x); \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding4, __rselect, __SlidingCoordNewP, __y_next, __x); \
        /* Execute Kernel According to Boundary Conditions */ \
        if (__count >= __vecDELAY) { \
            OUTTYPE ## VECT_SIZE __outPixel;\
            _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
                INTYPE  __wnd[__SIZE_Y][__SIZE_X]; \
                INTYPE __wnd1[__SIZE_Y][__SIZE_X]; \
                INTYPE __wnd2[__SIZE_Y][__SIZE_X]; \
                INTYPE __wnd3[__SIZE_Y][__SIZE_X]; \
                INTYPE __wnd4[__SIZE_Y][__SIZE_X]; \
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE,  __wnd,  __wnd_sliding, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd1, __wnd_sliding1, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd2, __wnd_sliding2, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd3, __wnd_sliding3, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd4, __wnd_sliding4, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(__wnd, __wnd1, __wnd2, __wnd3, __wnd4);\
            }\
            write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count-__vecDELAY);\
           \
            __x+=VECT_SIZE; \
            const uint rflagCoord = __halfSIZE_X>VECT_SIZE ? __WIDTH-__Nvec*VECT_SIZE : __WIDTH-VECT_SIZE;\
            if(__x == rflagCoord){\
                __rselect=1;\
                __y_next++;\
            }else if (__x == __WIDTH) { \
                __x = 0; \
                __y = __y_next; \
                __rselect = 0;\
                __bVECT_INDX = (__Nvec-1) * VECT_SIZE;\
            }else if(__x > rflagCoord){\
                __bVECT_INDX-= VECT_SIZE;\
            }\
        } \
        ++__count; \
    }


#define processPixels3to1(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, SRC, READTYPE, SRC1, READTYPE1, SRC2, READTYPE2, IM_WIDTH, IM_HEIGHT, KERNEL) \
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    \
    uint __count = 0; \
    uint __x = 0, __y = 0;\
    while (__count != __vecSIZE) { \
        INTYPE ## VECT_SIZE __newpixel; \
        INTYPE ## VECT_SIZE __newpixel1; \
        INTYPE ## VECT_SIZE __newpixel2; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
            readPixelf ## READTYPE1(VECT_SIZE, INTYPE, __newpixel1, SRC1, __count);\
            readPixelf ## READTYPE2(VECT_SIZE, INTYPE, __newpixel2, SRC2, __count);\
        }\
        /* Execute Kernel According to Boundary Conditions */ \
        OUTTYPE ## VECT_SIZE __outPixel;\
        _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
            ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(((INTYPE*)&__newpixel)[__vi], ((INTYPE*)&__newpixel1)[__vi], ((INTYPE*)&__newpixel2)[__vi]);\
        }\
        write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count);\
       \
        __x+=VECT_SIZE; \
        if(__x == __WIDTH-VECT_SIZE){\
            __x = 0; \
            __y++;\
        }\
        __count++; \
    }


#define process3to1(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, SRC, READTYPE, SRC1, READTYPE1, SRC2, READTYPE2, IM_WIDTH, IM_HEIGHT, KERNEL, KRNL_SIZE_X, KRNL_SIZE_Y, BORDER, ...) \
    const int __SIZE_X = KRNL_SIZE_X;\
    const int __SIZE_Y = KRNL_SIZE_Y;\
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const int __halfSIZE_Y = (__SIZE_Y >> 1);\
    const int __halfSIZE_X = (__SIZE_X >> 1);\
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    const uint __DELAY     = ((__WIDTH*__halfSIZE_Y) + __halfSIZE_X);\
    \
    const uint __vecWIDTH = ((__WIDTH-1)/VECT_SIZE)+1; \
    const uint __vecDELAY = ((__DELAY-1)/VECT_SIZE)+1; \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    const uint __Nvec = ((__halfSIZE_X-1)/VECT_SIZE)+1;\
    const uint __SlidingSIZE = __halfSIZE_X+(1+__Nvec)*VECT_SIZE+__halfSIZE_X;\
    const uint __SlidingCoordNewP = __SlidingSIZE-__halfSIZE_X-VECT_SIZE;\
    \
    uint __count = 0; \
    uint __x = 0, __y = 0, __y_next = 0;\
    bool __rselect=0; \
    uint __bVECT_INDX = (__Nvec-1)*VECT_SIZE;\
    /* 0th Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding[__SIZE_Y][__SlidingSIZE]; \
    /* 1st Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows1[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding1[__SIZE_Y][__SlidingSIZE]; \
    /* 2nd Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows2[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding2[__SIZE_Y][__SlidingSIZE]; \
    while (__count != __vecDELAY+__vecSIZE) { \
        /* Shift Row Buffers and Sliding Window */ \
        _Pragma("unroll") \
        for(uint __j=0; __j<__SIZE_Y-1; ++__j){ \
            INTYPE ## VECT_SIZE __newPixel  =  __rows[__j][__vecWIDTH-1]; \
            INTYPE ## VECT_SIZE __newPixel1 = __rows1[__j][__vecWIDTH-1]; \
            INTYPE ## VECT_SIZE __newPixel2 = __rows2[__j][__vecWIDTH-1]; \
            if(__j != 0){\
                 __rows[__j-1][0] = __newPixel;\
                __rows1[__j-1][0] = __newPixel1;\
                __rows2[__j-1][0] = __newPixel2;\
            }\
            _Pragma("unroll") \
            for(uint __i = __vecWIDTH-1; __i > 0; --__i){\
              __rows[__j][__i]  =  __rows[__j][__i - 1]; \
              __rows1[__j][__i] = __rows1[__j][__i - 1]; \
              __rows2[__j][__i] = __rows2[__j][__i - 1]; \
            }\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE,  __wnd_sliding,  __newPixel, __SlidingCoordNewP, __j, __x);\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding1, __newPixel1, __SlidingCoordNewP, __j, __x);\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding2, __newPixel2, __SlidingCoordNewP, __j, __x);\
        }\
        INTYPE ## VECT_SIZE __newpixel; \
        INTYPE ## VECT_SIZE __newpixel1; \
        INTYPE ## VECT_SIZE __newpixel2; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
            __rows[__SIZE_Y-2][0] = __newpixel; \
            readPixelf ## READTYPE1(VECT_SIZE, INTYPE, __newpixel1, SRC1, __count);\
            __rows1[__SIZE_Y-2][0] = __newpixel1; \
            readPixelf ## READTYPE2(VECT_SIZE, INTYPE, __newpixel2, SRC2, __count);\
            __rows2[__SIZE_Y-2][0] = __newpixel2; \
        }\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE , __wnd_sliding,  __newpixel, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding1, __newpixel1, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding2, __newpixel2, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        /* Warp pixel row coming from row buffer */ \
        WARPy_ ## BORDER(VECT_SIZE,  __wnd_sliding, __rselect, __SlidingCoordNewP, __y_next, __x); \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding1, __rselect, __SlidingCoordNewP, __y_next, __x); \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding2, __rselect, __SlidingCoordNewP, __y_next, __x); \
        /* Execute Kernel According to Boundary Conditions */ \
        if (__count >= __vecDELAY) { \
            OUTTYPE ## VECT_SIZE __outPixel;\
            _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
                INTYPE  __wnd[__SIZE_Y][__SIZE_X]; \
                INTYPE __wnd1[__SIZE_Y][__SIZE_X]; \
                INTYPE __wnd2[__SIZE_Y][__SIZE_X]; \
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE,  __wnd,  __wnd_sliding, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd1, __wnd_sliding1, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd2, __wnd_sliding2, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(__wnd, __wnd1, __wnd2);\
            }\
            write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count-__vecDELAY);\
           \
            __x+=VECT_SIZE; \
            const uint rflagCoord = __halfSIZE_X>VECT_SIZE ? __WIDTH-__Nvec*VECT_SIZE : __WIDTH-VECT_SIZE;\
            if(__x == rflagCoord){\
                __rselect=1;\
                __y_next++;\
            }else if (__x == __WIDTH) { \
                __x = 0; \
                __y = __y_next; \
                __rselect = 0;\
                __bVECT_INDX = (__Nvec-1) * VECT_SIZE;\
            }else if(__x > rflagCoord){\
                __bVECT_INDX-= VECT_SIZE;\
            }\
        } \
        ++__count; \
    }

#define processPixels2to1(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, SRC, READTYPE, SRC1, READTYPE1, IM_WIDTH, IM_HEIGHT, KERNEL) \
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    \
    uint __count = 0; \
    uint __x = 0, __y = 0;\
    while (__count != __vecSIZE) { \
        INTYPE ## VECT_SIZE __newpixel; \
        INTYPE ## VECT_SIZE __newpixel1; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
            readPixelf ## READTYPE1(VECT_SIZE, INTYPE, __newpixel1, SRC1, __count);\
        }\
        /* Execute Kernel According to Boundary Conditions */ \
        OUTTYPE ## VECT_SIZE __outPixel;\
        _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
            ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(((INTYPE*)&__newpixel)[__vi], ((INTYPE*)&__newpixel1)[__vi]);\
        }\
        write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count);\
       \
        __x+=VECT_SIZE; \
        if(__x == __WIDTH-VECT_SIZE){\
            __x = 0; \
            __y++;\
        }\
        __count++; \
    }


#define process2to1(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, SRC, READTYPE, SRC1, READTYPE1, IM_WIDTH, IM_HEIGHT, KERNEL, KRNL_SIZE_X, KRNL_SIZE_Y, BORDER, ...) \
    const int __SIZE_X = KRNL_SIZE_X;\
    const int __SIZE_Y = KRNL_SIZE_Y;\
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const int __halfSIZE_Y = (__SIZE_Y >> 1);\
    const int __halfSIZE_X = (__SIZE_X >> 1);\
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    const uint __DELAY     = ((__WIDTH*__halfSIZE_Y) + __halfSIZE_X);\
    \
    const uint __vecWIDTH = ((__WIDTH-1)/VECT_SIZE)+1; \
    const uint __vecDELAY = ((__DELAY-1)/VECT_SIZE)+1; \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    const uint __Nvec = ((__halfSIZE_X-1)/VECT_SIZE)+1;\
    const uint __SlidingSIZE = __halfSIZE_X+(1+__Nvec)*VECT_SIZE+__halfSIZE_X;\
    const uint __SlidingCoordNewP = __SlidingSIZE-__halfSIZE_X-VECT_SIZE;\
    \
    uint __count = 0; \
    uint __x = 0, __y = 0, __y_next = 0;\
    bool __rselect=0; \
    uint __bVECT_INDX = (__Nvec-1)*VECT_SIZE;\
    /* 0th Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding[__SIZE_Y][__SlidingSIZE]; \
    /* 1st Process Row Buffer and Sliding Window */\
    INTYPE ## VECT_SIZE __rows1[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding1[__SIZE_Y][__SlidingSIZE]; \
    while (__count != __vecDELAY+__vecSIZE) { \
        /* Shift Row Buffers and Sliding Window */ \
        _Pragma("unroll") \
        for(uint __j=0; __j<__SIZE_Y-1; ++__j){ \
            INTYPE ## VECT_SIZE __newPixel  =  __rows[__j][__vecWIDTH-1]; \
            INTYPE ## VECT_SIZE __newPixel1 = __rows1[__j][__vecWIDTH-1]; \
            if(__j != 0){\
                 __rows[__j-1][0] = __newPixel;\
                __rows1[__j-1][0] = __newPixel1;\
            }\
            _Pragma("unroll") \
            for(uint __i = __vecWIDTH-1; __i > 0; --__i){\
              __rows[__j][__i]  =  __rows[__j][__i - 1]; \
              __rows1[__j][__i] = __rows1[__j][__i - 1]; \
            }\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE,  __wnd_sliding,  __newPixel, __SlidingCoordNewP, __j, __x);\
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding1, __newPixel1, __SlidingCoordNewP, __j, __x);\
        }\
        INTYPE ## VECT_SIZE __newpixel; \
        INTYPE ## VECT_SIZE __newpixel1; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
            __rows[__SIZE_Y-2][0] = __newpixel; \
            readPixelf ## READTYPE1(VECT_SIZE, INTYPE, __newpixel1, SRC1, __count);\
            __rows1[__SIZE_Y-2][0] = __newpixel1; \
        }\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE , __wnd_sliding,  __newpixel, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding1, __newpixel1, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        /* Warp pixel row coming from row buffer */ \
        WARPy_ ## BORDER(VECT_SIZE,  __wnd_sliding, __rselect, __SlidingCoordNewP, __y_next, __x); \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding1, __rselect, __SlidingCoordNewP, __y_next, __x); \
        /* Execute Kernel According to Boundary Conditions */ \
        if (__count >= __vecDELAY) { \
            OUTTYPE ## VECT_SIZE __outPixel;\
            _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
                INTYPE  __wnd[__SIZE_Y][__SIZE_X]; \
                INTYPE __wnd1[__SIZE_Y][__SIZE_X]; \
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE,  __wnd,  __wnd_sliding, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd1, __wnd_sliding1, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(__wnd, __wnd1);\
            }\
            write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count-__vecDELAY);\
           \
            __x+=VECT_SIZE; \
            const uint rflagCoord = __halfSIZE_X>VECT_SIZE ? __WIDTH-__Nvec*VECT_SIZE : __WIDTH-VECT_SIZE;\
            if(__x == rflagCoord){\
                __rselect=1;\
                __y_next++;\
            }else if (__x == __WIDTH) { \
                __x = 0; \
                __y = __y_next; \
                __rselect = 0;\
                __bVECT_INDX = (__Nvec-1) * VECT_SIZE;\
            }else if(__x > rflagCoord){\
                __bVECT_INDX-= VECT_SIZE;\
            }\
        } \
        ++__count; \
    }

/* ******************Multiple Outputs********************************* */

#define processPixels2to2(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, DST1, WRTTYPE1, SRC, READTYPE, SRC1, READTYPE1, IM_WIDTH, IM_HEIGHT, KERNEL) \
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    \
    uint __count = 0; \
    uint __x = 0, __y = 0;\
    while (__count != __vecSIZE) { \
        INTYPE ## VECT_SIZE __newpixel; \
        INTYPE ## VECT_SIZE __newpixel1; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
            readPixelf ## READTYPE1(VECT_SIZE, INTYPE, __newpixel1, SRC1, __count);\
        }\
        /* Execute Kernel According to Boundary Conditions */ \
        OUTTYPE ## VECT_SIZE __outPixel;\
        _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
            ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(((INTYPE*)&__newpixel)[__vi], ((INTYPE*)&__newpixel1)[__vi]);\
        }\
        write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count);\
        write2 ## WRTTYPE1(VECT_SIZE, OUTTYPE, DST1, __outPixel, __count);\
       \
        __x+=VECT_SIZE; \
        if(__x == __WIDTH-VECT_SIZE){\
            __x = 0; \
            __y++;\
        }\
        __count++; \
    }


#define processPixels1to2(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, DST1, WRTTYPE1, SRC, READTYPE, IM_WIDTH, IM_HEIGHT, KERNEL) \
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    \
    uint __count = 0; \
    uint __x = 0, __y = 0;\
    while (__count != __vecSIZE) { \
        INTYPE ## VECT_SIZE __newpixel; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
        }\
        /* Execute Kernel According to Boundary Conditions */ \
        OUTTYPE ## VECT_SIZE __outPixel;\
        _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
            ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(((INTYPE*)&__newpixel)[__vi]);\
        }\
        write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count);\
        write2 ## WRTTYPE1(VECT_SIZE, OUTTYPE, DST1, __outPixel, __count);\
       \
        __x+=VECT_SIZE; \
        if(__x == __WIDTH-VECT_SIZE){\
            __x = 0; \
            __y++;\
        }\
        __count++; \
    }

#define process1to2(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, DST1, WRTTYPE1, SRC, READTYPE, IM_WIDTH, IM_HEIGHT, KERNEL, KRNL_SIZE_X, KRNL_SIZE_Y, BORDER, ...) \
    const int __SIZE_X = KRNL_SIZE_X;\
    const int __SIZE_Y = KRNL_SIZE_Y;\
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const int __halfSIZE_Y = (__SIZE_Y >> 1);\
    const int __halfSIZE_X = (__SIZE_X >> 1);\
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    const uint __DELAY     = ((__WIDTH*__halfSIZE_Y) + __halfSIZE_X);\
    \
    const uint __vecWIDTH = ((__WIDTH-1)/VECT_SIZE)+1; \
    const uint __vecDELAY = ((__DELAY-1)/VECT_SIZE)+1; \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    const uint __Nvec = ((__halfSIZE_X-1)/VECT_SIZE)+1;\
    const uint __SlidingSIZE = __halfSIZE_X+(1+__Nvec)*VECT_SIZE+__halfSIZE_X;\
    const uint __SlidingCoordNewP = __SlidingSIZE-__halfSIZE_X-VECT_SIZE;\
    \
    INTYPE ## VECT_SIZE __rows[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding[__SIZE_Y][__SlidingSIZE]; \
    uint __count = 0; \
    uint __x = 0, __y = 0, __y_next = 0;\
    bool __rselect=0; \
    uint __bVECT_INDX = (__Nvec-1)*VECT_SIZE;\
    while (__count != __vecDELAY+__vecSIZE) { \
        /* Shift Row Buffers and Sliding Window */ \
        _Pragma("unroll") \
        for(uint __j=0; __j<__SIZE_Y-1; ++__j){ \
            INTYPE ## VECT_SIZE __newPixel = __rows[__j][__vecWIDTH-1]; \
            if(__j != 0) __rows[__j-1][0] = __newPixel;\
            _Pragma("unroll") \
            for(uint __i = __vecWIDTH-1; __i > 0; --__i) __rows[__j][__i] = __rows[__j][__i - 1]; \
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding, __newPixel, __SlidingCoordNewP, __j, __x);\
        }\
        INTYPE ## VECT_SIZE __newpixel; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
            __rows[__SIZE_Y-2][0] = __newpixel; \
        }\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding, __newpixel, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        /* Warp pixel row coming from row buffer */ \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding, __rselect, __SlidingCoordNewP, __y_next, __x); \
        /* Execute Kernel According to Boundary Conditions */ \
        if (__count >= __vecDELAY) { \
            OUTTYPE ## VECT_SIZE __outPixel;\
            _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
                INTYPE __wnd[__SIZE_Y][__SIZE_X]; \
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd, __wnd_sliding, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(__wnd);\
            }\
            write2 ## WRTTYPE(VECT_SIZE, OUTTYPE,  DST, __outPixel, __count-__vecDELAY);\
            write2 ## WRTTYPE1(VECT_SIZE, OUTTYPE, DST1, __outPixel, __count-__vecDELAY);\
           \
            __x+=VECT_SIZE; \
            const uint rflagCoord = __halfSIZE_X>VECT_SIZE ? __WIDTH-__Nvec*VECT_SIZE : __WIDTH-VECT_SIZE;\
            if(__x == rflagCoord){\
                __rselect=1;\
                __y_next++;\
            }else if (__x == __WIDTH) { \
                __x = 0; \
                __y = __y_next; \
                __rselect = 0;\
                __bVECT_INDX = (__Nvec-1) * VECT_SIZE;\
            }else if(__x > rflagCoord){\
                __bVECT_INDX-= VECT_SIZE;\
            }\
        } \
        ++__count; \
    }


#define process1to3(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, DST1, WRTTYPE1, DST2, WRTTYPE2, SRC, READTYPE, IM_WIDTH, IM_HEIGHT, KERNEL, KRNL_SIZE_X, KRNL_SIZE_Y, BORDER, ...) \
    const int __SIZE_X = KRNL_SIZE_X;\
    const int __SIZE_Y = KRNL_SIZE_Y;\
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const int __halfSIZE_Y = (__SIZE_Y >> 1);\
    const int __halfSIZE_X = (__SIZE_X >> 1);\
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    const uint __DELAY     = ((__WIDTH*__halfSIZE_Y) + __halfSIZE_X);\
    \
    const uint __vecWIDTH = ((__WIDTH-1)/VECT_SIZE)+1; \
    const uint __vecDELAY = ((__DELAY-1)/VECT_SIZE)+1; \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    const uint __Nvec = ((__halfSIZE_X-1)/VECT_SIZE)+1;\
    const uint __SlidingSIZE = __halfSIZE_X+(1+__Nvec)*VECT_SIZE+__halfSIZE_X;\
    const uint __SlidingCoordNewP = __SlidingSIZE-__halfSIZE_X-VECT_SIZE;\
    \
    INTYPE ## VECT_SIZE __rows[__SIZE_Y-1][__vecWIDTH];\
    INTYPE __wnd_sliding[__SIZE_Y][__SlidingSIZE]; \
    uint __count = 0; \
    uint __x = 0, __y = 0, __y_next = 0;\
    bool __rselect=0; \
    uint __bVECT_INDX = (__Nvec-1)*VECT_SIZE;\
    while (__count != __vecDELAY+__vecSIZE) { \
        /* Shift Row Buffers and Sliding Window */ \
        _Pragma("unroll") \
        for(uint __j=0; __j<__SIZE_Y-1; ++__j){ \
            INTYPE ## VECT_SIZE __newPixel = __rows[__j][__vecWIDTH-1]; \
            if(__j != 0) __rows[__j-1][0] = __newPixel;\
            _Pragma("unroll") \
            for(uint __i = __vecWIDTH-1; __i > 0; --__i) __rows[__j][__i] = __rows[__j][__i - 1]; \
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding, __newPixel, __SlidingCoordNewP, __j, __x);\
        }\
        INTYPE ## VECT_SIZE __newpixel; \
        if (__count < __vecSIZE) { \
            readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
            __rows[__SIZE_Y-2][0] = __newpixel; \
        }\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding, __newpixel, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        /* Warp pixel row coming from row buffer */ \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding, __rselect, __SlidingCoordNewP, __y_next, __x); \
        /* Execute Kernel According to Boundary Conditions */ \
        if (__count >= __vecDELAY) { \
            OUTTYPE ## VECT_SIZE __outPixel;\
            _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
                INTYPE __wnd[__SIZE_Y][__SIZE_X]; \
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd, __wnd_sliding, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(__wnd);\
            }\
            write2 ## WRTTYPE(VECT_SIZE, OUTTYPE,  DST, __outPixel, __count-__vecDELAY);\
            write2 ## WRTTYPE1(VECT_SIZE, OUTTYPE, DST1, __outPixel, __count-__vecDELAY);\
            write2 ## WRTTYPE2(VECT_SIZE, OUTTYPE, DST2, __outPixel, __count-__vecDELAY);\
           \
            __x+=VECT_SIZE; \
            const uint rflagCoord = __halfSIZE_X>VECT_SIZE ? __WIDTH-__Nvec*VECT_SIZE : __WIDTH-VECT_SIZE;\
            if(__x == rflagCoord){\
                __rselect=1;\
                __y_next++;\
            }else if (__x == __WIDTH) { \
                __x = 0; \
                __y = __y_next; \
                __rselect = 0;\
                __bVECT_INDX = (__Nvec-1) * VECT_SIZE;\
            }else if(__x > rflagCoord){\
                __bVECT_INDX-= VECT_SIZE;\
            }\
        } \
        ++__count; \
    }


/* **********VECTORIZED PIPELINE FUNCTION with SMALL ROW BUFFER************** */

#define processB(VECT_SIZE, OUTTYPE, INTYPE, DST, WRTTYPE, SRC, READTYPE, IM_WIDTH, IM_HEIGHT, KERNEL, KRNL_SIZE_X, KRNL_SIZE_Y, BORDER, ...) \
    const int __SIZE_X = FILT_SIZE_X;\
    const int __SIZE_Y = FILT_SIZE_Y;\
    const int __WIDTH  = IM_WIDTH;\
    const int __HEIGHT = IM_HEIGHT;\
    \
    const int __halfSIZE_Y = (__SIZE_Y >> 1);\
    const int __halfSIZE_X = (__SIZE_X >> 1);\
    const uint __SIZE      = (__WIDTH * __HEIGHT);\
    const uint __DELAY     = ((__WIDTH*__halfSIZE_Y) + __halfSIZE_X);\
    \
    const uint __vecDELAY = ((__DELAY-1)/VECT_SIZE)+1; \
    const uint __vecSIZE  = ((__SIZE-1)/VECT_SIZE)+1; \
    const uint __Nvec = ((__halfSIZE_X-1)/VECT_SIZE)+1;\
    const uint __vecWIDTHpadded = ((__WIDTH-1)/VECT_SIZE)+1; \
    const uint __vecWIDTH = __vecWIDTHpadded-(1+__Nvec); \
    const uint __SlidingSIZE = __halfSIZE_X+(1+__Nvec)*VECT_SIZE+__halfSIZE_X;\
    const uint __SlidingCoordNewP = __SlidingSIZE-__halfSIZE_X-VECT_SIZE;\
    \
    INTYPE ## VECT_SIZE __rows[__SIZE_Y-1][__vecWIDTHpadded];\
    INTYPE __wnd_sliding[__SIZE_Y][__SlidingSIZE]; \
    uint __count = 0; \
    uint __x = 0, __y = 0, __y_next = 0;\
    bool __rselect=0; \
    uint __bVECT_INDX = (__Nvec-1)*VECT_SIZE;\
    while (__count != __vecDELAY+__vecSIZE) { \
        /* Shift Row Buffers and Sliding Window */ \
        _Pragma("unroll") \
        for(uint __j=0; __j<__SIZE_Y-1; ++__j){ \
            SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE, __wnd_sliding, __rows[__j][__vecWIDTH-1], __SlidingCoordNewP, __j, __x);\
            _Pragma("unroll") \
            for(uint __i = __vecWIDTH-1; __i > 0; --__i) __rows[__j][__i] = __rows[__j][__i - 1]; \
            _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++)\
                ((OUTTYPE*)&__rows[__j][0])[__vi] = ((INTYPE*)&__wnd_sliding[__j+1][__halfSIZE_X])[__vi];\
        }\
        INTYPE ## VECT_SIZE __newpixel; \
        if (__count < __vecSIZE)  readPixelf ## READTYPE(VECT_SIZE, INTYPE, __newpixel, SRC, __count);\
        SLIDEWx_ ## BORDER(VECT_SIZE, INTYPE ,__wnd_sliding, __newpixel, __SlidingCoordNewP, __SIZE_Y-1, __x);\
        /* Warp pixel row coming from row buffer */ \
        WARPy_ ## BORDER(VECT_SIZE, __wnd_sliding, __rselect, __SlidingCoordNewP, __y_next, __x); \
        /* Execute Kernel According to Boundary Conditions */ \
        if (__count >= __vecDELAY) { \
            OUTTYPE ## VECT_SIZE __outPixel;\
            _Pragma("unroll") for(int __vi=0; __vi<VECT_SIZE; __vi++){\
                INTYPE __wnd[__SIZE_Y][__SIZE_X]; \
                SELECT_OUT_ ## BORDER(__bVECT_INDX, __vi, VECT_SIZE, __wnd, __wnd_sliding, __rselect, __SlidingSIZE, __y, __x, ##__VA_ARGS__);\
                ((OUTTYPE*)&__outPixel)[__vi] = KERNEL(__wnd);\
            }\
            write2 ## WRTTYPE(VECT_SIZE, OUTTYPE, DST, __outPixel, __count-__vecDELAY);\
           \
            __x+=VECT_SIZE; \
            const uint rflagCoord = __halfSIZE_X>VECT_SIZE ? __WIDTH-__Nvec*VECT_SIZE : __WIDTH-VECT_SIZE;\
            if(__x == rflagCoord){\
                __rselect=1;\
                __y_next++;\
            }else if (__x == __WIDTH) { \
                __x = 0; \
                __y = __y_next; \
                __rselect = 0;\
                __bVECT_INDX = (__Nvec-1) * VECT_SIZE;\
            }else if(__x > rflagCoord){\
                __bVECT_INDX-= VECT_SIZE;\
            }\
        } \
        ++__count; \
    }




//if( (__x<=2 && __x>=248) && __y<1 ){ \
//   printf("wnd_SLD = {__y = %u __x = %u}\n",__y, __x);\
//   for (uint __j = 0; __j < __SIZE_Y; ++__j) { \
//       for (uint __i = 0; __i < __SlidingSIZE; ++__i) { \
//           printf("wndS[%u][%u]=%d\t",__j,__i, __wnd_sliding[__j][__i]);\
//       } \
//       printf("\n");\
//   } \
//}\
//
//
//
//
//
//if( (__x<=2 && __x>=252) && __y<1 ){ \
//   printf("__vi = %u\n", __vi);\
//   printf("__bVECT_INDX = %u\n",__bVECT_INDX);\
//   printf("wnd_OUT = {__y = %u __x = %u}\n",__y, __x+__vi);\
//   for (uint __j = 0; __j < __SIZE_Y; ++__j) { \
//       for (uint __i = 0; __i < __SIZE_X; ++__i) { \
//           printf("wndO[%u][%u]=%d\t",__j,__i, __wnd[__j][__i]);\
//       } \
//       printf("\n");\
//   } \
//}\
